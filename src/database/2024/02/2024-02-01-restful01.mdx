---
slug: "/rest01/"
date: 2024-02-01 17:57:44 +0000
modified: 2024-02-01 17:57:44 +0000
title: "[TIL] REST를 설명해보세요"
author: Kimson
categories: [javascript]
image: /assets/images/post/covers/dalle-til-cover-edit.png
tags: [til, theory, rest, restful, restful-api]
description: "누군가 RESTful에 대해 설명해보라고 한다면 \"과연 내가 어디서부터 어디까지 이야기할 수 있을까\"에 대한 물음이 생겨서 포스팅을 시작하게 되었습니다.

기술면접에서 등장하는 질문 중에 하나로 꼽히고, 그 질문을 저 또한 받아 답하지 못했습니다. 꼭 면접이 아니더라도 백엔드 개발자로서 알고 있어야하는 부분임은 분명합니다.

REST는 무엇인가

REST는 크게 서비스 아키텍처에 속하며, 웹 아키텍처 스타일의 한 형태입니다. REST는 일련의 \"표준\"이 아닌 \"소프트웨어 아키텍처 스타일\"이라는 점을 유의해야합니다."
featured: true
rating: 4.5
profile: false
published: true
---

누군가 RESTful에 대해 설명해보라고 한다면 "과연 내가 어디서부터 어디까지 이야기할 수 있을까"에 대한 물음이 생겨서 포스팅을 시작하게 되었습니다.

기술면접에서 등장하는 질문 중에 하나로 꼽히고, 그 질문을 저 또한 받아 답하지 못했습니다. 꼭 면접이 아니더라도 백엔드 개발자로서 알고 있어야하는 부분임은 분명합니다.

# REST는 무엇인가

REST는 크게 서비스 아키텍처에 속하며, 웹 아키텍처 스타일의 한 형태입니다. REST는 일련의 "표준"이 아닌 "소프트웨어 아키텍처 스타일"이라는 점을 유의해야합니다.

REST는 Representational State Transfer, 직역하면 "표현 상태 전송"이라고 합니다. REST는 네트워크 리소스를 정의하고 처리하는 방법을 설명하는 일련의 원칙을 기반으로 하는 아키텍처 스타일입니다. 이 원리는 2000년 Roy Fielding(로이 필딩) 박사 학위 논문에서 처음으로 등장한 단어입니다. REST는 **SOAP** 및 **JSON**의 **대안**이라고 합니다.

`RESTful`은 `REST 원칙`을 따르는 시스템이나 서비스를 가리키는 용어로, RESTful 시스템이나 서비스는 REST 아키텍처 스타일을 채택하여 구현된 것을 의미합니다.

여기서 RESTful은 단순히 HTTP나 WWW가 아닌 아주 커다란 소프트웨어 시스템을 설계하는 것도 가능합니다.

개인적으로 해석하기에는 REST라는 서비스 아키텍처는 하나의 아키텍처 스타일이며 이 개념을 따르는 API를 RESTful API라고 칭할 뿐이지 더 넓은 영역에서 적용이 가능하기 때문에 꼭 RESTful은 API에만 붙일 수 있는 것은 아니라는 생각이지요.

> REST는 원틱과 아키텍처 스타일을 정의하는 개념이고, RESTful은 이 원틱을 따르는 구체적인 구현을 가리키는 용어라고 할 수 있습니다. 예를 들어, RESTful API라고 하는 말은 REST 원칙에 따라 설계된 API를 지칭합니다.

## RESTful의 조건과 부합하는 API의 구현 조건

그렇다면 REST에 대한 기본적인 개념이 잡혔고, 이 REST를 API개발자가 활용하려면 어떻게 해야할까? API가 RESTful로 간주되려면 기준이 되는 조건이 있습니다.

- 균일한 인터페이스
- 무상태(Stateless)
- 캐시처리 가능
- 계층화
- 클라이언트/서버 구조
- 온디맨드 코드

### 균일한 인터페이스

인터페이스가 일관되도록 분리되는 것은 모든 RESTful 웹 서비스 디자인의 기본이 됩니다. 서버가 표준 형식으로 정보를 전송함을 나타내는데, 형식이 지정된 리소스를 REST에서는 "표현(Representation)"이라고 합니다.

여기서 균일한 인터페이스에는 4가지 아키텍처 제약 조건이 있습니다.

1. 식별 가능한 리소스
   - 요청은 리소스를 식별해야 한다. 때문에 균일한 리소스 식별자를 사용해야 한다.
2. 메시지를 통한 리소스 조작
   - 클라이언트는 원하는 경우 리소스를 수정하거나 삭제하기에 충분한 정보를 리소스 표현에 포함해야 한다. 서버는 리소스를 자세히 설명하는 메타데이터를 전송해 이 조건을 충족해야 한다.
3. 자기 서술적 메시지
   - 클라이언트는 표현을 추가로 처리하는 방법에 대한 정보를 수신한다. 서버는 클라이언트가 리소스를 적정하게 사용할 수 있는 방법에 대한 메타데이터가 포함된 명확한 메시지를 전송한다.
4. HATEOAS
   - 클라이언트는 작업을 완료하는 데 필요한 다른 모든 관련 리소스에 대한 정보를 수신한다. 서버는 클라이언트가 더 많은 리소스를 동적으로 검색할 수 있도록 표현에 하이퍼링크를 넣어 전송한다.

API 서버를 제작하는 과정으로 예시를 들어보면 좀 더 이해하기 쉬울 것 같아 예시를 추가합니다.

1번의 경우 요청은 리소스를 식별해야하기 때문에 균일한 리소스 식별자를 사용해야합니다. 즉, 리소스 식별을 위해 흔히 `/users/:id` 와 같이 url 스키마를 사용하는 것을 예로 들 수 있습니다.

```javascript
const express = require("express");
const app = express();
const port = 3000;

// 사용자 데이터 예시
const users = [
  { id: 1, name: "Kim", age: 30 },
  { id: 2, name: "Lee", age: 25 },
];

// 모든 사용자 조회
app.get("/users", (req, res) => {
  res.json(users);
});

// 특정 사용자 조회
app.get("/users/:id", (req, res) => {
  const user = users.find((u) => u.id == req.params.id);
  if (user) {
    res.json(user);
  } else {
    res.status(404).send("User not found");
  }
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}/`);
});
```

이렇게 `/users/:id` 와 같이 사용한다면 요청은 리소스를 식별하는데 있어서 균일한 리소스 식별자를 사용하기 때문에 REST 조건에 부합한다고 볼 수 있습니다.

2번의 경우 요약해서 말하자면 클라이언트가 수정, 삭제가 필요할 때 리소스는 이에 필요한 정보를 충분히 포함하고 있어야한다는 이야기입니다. 이 정보는 보통 서버에서 정해서 내려줍니다.

```javascript
app.get("/users/:id", (req, res) => {
  const user = users.find((u) => u.id == req.params.id);
  if (user) {
    res.json(user);
  } else {
    res.status(404).send("User not found");
  }
});
```

위 코드에서 보면 `user`데이터를 응답하게 되는데, 수정과 삭제에 필요한 `id`값과 그 외 정보가 리소스에 반영되어 응답합니다. 이 정보를 통해서 리소스를 수신한 클라이언트는 데이터를 수정, 삭제하는 요청을 합니다.

3번의 경우 클라이언트가 리소스를 적정하게 사용할 수 있도록 서버는 명확한 메타데이터를 포함한 메시지를 전송해야합니다. 위의 코드를 변경해서 예시를 보겠습니다.

```javascript
// 특정 사용자 조회
app.get("/users/:id", (req, res) => {
  const user = users.find((u) => u.id == req.params.id);
  if (user) {
    // Content-Type 및 기타 메타데이터 전송
    res.setHeader("Content-Type", "application/json");
    res.setHeader("X-Total-Count", users.length.toString());
    res.json(user);
  } else {
    res.status(404).send("User not found");
  }
});
```

여기서 메시지는 Content-Type과 같은 헤더를 포함하여 본문이 JSON형식임을 나타내고 있습니다.

4번은 클라이언트가 동적으로 리소스를 검색할 수 있도록 서버에서 하이퍼링크를 전송하는 것을 예로 들 수 있습니다. 특히 페이지를 구성하는 서비스를 구현한다면 유용하게 사용될 수 있는 부분입니다.

```javascript
const express = require("express");
const app = express();
const port = 3000;

// 데이터 예시
const books = [
  { id: 1, title: "Book 1", author: "Author 1" },
  { id: 2, title: "Book 2", author: "Author 2" },
];

// 모든 책 목록 조회
app.get("/books", (req, res) => {
  res.json(
    books.map((book) => {
      return {
        ...book,
        links: {
          self: `http://localhost:${port}/books/${book.id}`,
          reviews: `http://localhost:${port}/books/${book.id}/reviews`,
        },
      };
    })
  );
});

// 특정 책 조회
app.get("/books/:id", (req, res) => {
  const book = books.find((b) => b.id == req.params.id);
  if (book) {
    res.json({
      ...book,
      links: {
        allBooks: `http://localhost:${port}/books`,
        reviews: `http://localhost:${port}/books/${book.id}/reviews`,
      },
    });
  } else {
    res.status(404).send("Book not found");
  }
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}/`);
});
```

서적을 검색하는 서비스를 예로 들었습니다. 클라이언트가 다른 리소스를 필요로 할 때, 서버에서 하이퍼링크를 메시지에 포함하여 제공하면 관련된 리소스에 대한 정보를 별도로 클라이언트가 처리할 필요 없이 동적으로 리소스를 검색할 수 있습니다. 즉, 클라이언트가 API의 구조를 알 필요가 없으며 하이퍼미디어 링크를 포함한 응답을 통해 서적 저자 조회, 또는 서적 정보 수정 등의 추가적인 액션이 가능합니다.

### 무상태(Stateless)

REST 아키텍처에서 무상태는 서버가 이전의 모든 요청과 독립적으로 모든 클라이언트 요청을 완료하는 통신 방법을 말합니다. 클라이언트는 임의의 순서로 리소스를 요청할 수 있고, 모든 요청은 무상태이거나 다른 요청과 분리됩니다.

쉽게 말해, 요청 간에 클라이언트의 상태 정보를 저장하지 않는 원칙입니다. 클라이언트가 서버에 요청을 할 때마다, 그 요청에는 해당 요청을 이해하고 처리하는 데 필요한 모든 정보가 포함되어 있어야 합니다.

서버는 클라이언트의 이전 요청이나 상태에 대한 정보를 기억하지 않기 때문에 각 요청을 독립적으로 처리합니다.

반대로 말하자면, 서버가 클라이언트의 이전 요청을 포함하고 있다면, 요청에 헤더는 필요가 없겠지요. 이전의 요청에 대한 상태나 정보를 기억하지 않기 때문에 헤더에 클라이언트의 정보가 담기고, 독립적으로 요청을 처리하게 됩니다.

여기서 무상태의 특징을 이야기한다면, 요청이 독립적이기 때문에 시스템을 확장하기 쉽고, 요청을 별도로 처리하기 때문에 단순성과 명확성이 보장됩니다. 나아가 서버는 상태 정보를 유지하지 않기 때문에 요청은 어떠한 서버에 요청되더라도 라우팅될 수 있어 부하 분상이 용이합니다.

여기서 라우팅에 관한 내용은 로드 밸런싱 또는 요청을 우회하는 프록시 서버를 예로 들 수 있습니다.

반면, 상태를 저장하지 않기 때문에 데이터의 중복이 발생하고, 성능 저하로 이어질 수 있습니다.

### 캐시처리 가능

서버 응답 시간을 개선하기 위해 클라이언트 또는 중개자에 일부 응답을 저장하는 프로세스인 캐싱을 지원합니다. 예를 들어 모든 페이지에 공통 머리글 또는 푸터 이미지가 있는 웹 사이트를 방문할 때, 새로운 웹 사이트 페이지를 방문할 때마다 서버는 동일한 이미지를 다시 전송해야 합니다. 이를 피하기 위해서 클라이언트는 첫 번째 응답 이후 이미지를 캐싱하거나 저장한다음 캐시에서 직접 이미지를 사용합니다. RESTful 웹 서비스는 캐시 가능 또는 캐시 불가능으로 정의되는 API 응답을 사용하여 캐싱하게 됩니다.

```javascript
const express = require("express");
const app = express();
const port = 3000;

// 캐시 시간 설정 (예: 1시간)
const oneHour = 3600;

app.get("/some-resource", (req, res) => {
  // 캐시 헤더 설정
  res.set("Cache-Control", `public, max-age=${oneHour}`);

  // 리소스 응답
  res.send("This is a resource that can be cached.");
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

캐시 예시로 위 코드를 참고합니다. 여기서 `Cache-Control` 헤더를 포함하여 `max-age`를 지정하면 클라이언트에서 1시간 만큼 캐시할 수 있게 됩니다.

### 계층화

계층화된 시스템 아키텍처에서 클라이언트는 클라이언트와 서버 사이의 다른 승인된 중개자에게 연결할 수 있습니다. 요청된 정보를 검색하는 데 관련된 서버의 각 유형을 클라이언트는 볼 수 없는 계층 구조로 체계화하는 시스템을 말합니다.

즉, 클라이언트는 대상 서버에 직접 연결되었는지, 중간 서버를 통해 연결 되었는지 알 수 없습니다. 중간 서버는 로드 밸런싱 기능이나 공유 캐시 기능을 제공함으로써 시스템 규모 확장성을 향상시키는데 유용합니다.

### 클라이언트/서버 구조

아키텍처를 단순화시키고 작은 단위로 분리함으로써 각 파트가 독립적으로 개성 될 수 있도록 해줍니다. 클라이언트와 서버, 리소스로 구성되어 있고, 요청이 HTTP를 통해 관리되는 아키텍처입니다.

### 온디맨드 코드

자바 애플릿, 자바스크립트의 제공을 통해 서버가 클라이언트가 실행시킬 수 있는 로직을 전송해서 기능을 확장 시킬 수 있습니다.

NHN KCP를 예로 들겠습니다. NHN KCP를 사용한 경험이 있는 분은 아시겠지만, 제공되는 파일을 사용할 때 해당 파일은 외부로부터 스크립트 파일을 요청하고 응답 받아 기능을 확장시킵니다.

간소화한 예로는 다음과 같이 표현할 수 있습니다.

```javascript
// server.js
const express = require("express");
const app = express();
const port = 3000;
const cors = require("cors");

app.get("/get-code", (req, res) => {
  // 클라이언트가 실행할 JavaScript 코드 조각
  let clientCode = `console.log('This code is executed on the client.');`;
  clientCode += "window.extendsFeatures = {};";
  clientCode +=
    'window.extendsFeatures.alert = function() {alert("extends features!");}';
  res.setHeader("Access-Control-Allow-Origin", "http://localhost:5173");

  // JavaScript 코드를 응답으로 전송
  res.send(clientCode);
});

app.use(
  cors({
    origin: "*",
  })
);

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

```html
<!-- index.html -->
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Code on demand</title>
  </head>
  <body>
    <h1>Code on demand</h1>
    <script>
      fetch("http://localhost:3000/get-code", {})
        .then((res) => res.text())
        .then((code) => {
          console.log("code", code);
          // 확장 기능 적용
          new Function("", code).call();

          // 확장된 기능 사용
          console.log(window.extendsFeatures.alert());
        });
    </script>
  </body>
</html>
```

서버 측에서 Access-Control-Allow-Origin 헤더 값을 통해 cors를 방지합니다. 그리고 클라이언트에서 `get-code`로 요청을 보내면 서버로부터 확장 기능을 텍스트로 응답 받습니다. 클라이언트는 `eval`을 대신하여 `Function`인스턴스를 통해 확장 기능을 적용합니다. `eval`에 대한 위험성은 구글링을 통해 참고하시기 바랍니다.

다음은 클라이언트에서 온디맨드 코드가 동작하는 결과 이미지입니다.

![클라이언트 온디맨드 코드 예시](https://github.com/kkn1125/kkn1125.github.io/assets/71887242/27876018-dcb6-4042-b09f-024107af7809)

## 마무리

REST에 대해 알아보았습니다. 이 다음으로 RESTful API에 대한 내용이 이어지면 좋겠다 생각을 하지만 REST와 나누어서 포스팅하는게 REST를 이해하고 RESTful을 적용한 API 개발이라는 분류로 나눌 수 있다고 판단해서 여기서 마무리 짓도록 하겠습니다.

자료를 찾으면서 이해하고 저만의 방식으로 설명하기 위해 정리하다 보니 주입식으로 외우기 보다 자연스럽게 머릿속에 박히는 것 같습니다.

RESTful API는 다음 포스팅에서 이어가도록 하겠습니다.

---

[서비스 아키텍처 참조](https://www.service-architecture.com/articles/web-services/representational-state-transfer-rest.html)

[RESTful API 참조](https://aws.amazon.com/ko/what-is/restful-api/)
