---
slug: "/header01/"
date: 2023-08-19 21:12:30 +0000
modified: 2023-08-19 21:12:30 +0000
title: "[JAVASCRIPT] HTTP Header 톺아보기 01"
author: Kimson
categories: [javascript]
image: https://github.com/kkn1125/kkn1125.github.io/assets/71887242/f2e876a6-3a72-4bec-a84b-978ed81eb42a
tags: [http, header, cookie, session, cors, til]
description: "HTTP Header는 무엇일까?

http header는 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송할 수 있도록 해준다고 MDN에서 정리하고 있습니다.

헤더에는 간단한 규칙이 있습니다. 개발자 도구를 열어 네트워크 탭을 클릭해보면 해당 사이트에서 요청한 모든 정보를 볼 수가 있지요. MDN페이지의 HTTP 헤더 부분을 마침 보고 있으니 예시로 들겠습니다.

MDN::HTTP Header 네트워크 탭 예시

위 이미지는 MDN페이지에서 열어본 네트워크 탭이고, Header 라는 페이지를 요청한 정보를 열람하는 모습입니다.

크게 보면 일반, 응답, 요청 헤더로 나뉩니다. 일반에는 요청 URL, 요청 메서드, 상태 코드, 원격 주소, 리퍼러 정책이 있지요.

이번 포스팅에서는 헤더가 무엇인지 살펴보고, 클라이언트에서 헤더를 읽는 것을 서버에서 제어하는 방법과 요청 시 자동으로 헤더에 담기는 값이 무엇인지 등을 기록하고자 합니다."
featured: true
rating: 4.5
profile: false
published: true
---

# HTTP Header는 무엇일까?

`http header`는 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송할 수 있도록 해준다고 `MDN`에서 정리하고 있습니다.

헤더에는 간단한 규칙이 있습니다. 개발자 도구를 열어 네트워크 탭을 클릭해보면 해당 사이트에서 요청한 모든 정보를 볼 수가 있지요. `MDN`페이지의 `HTTP 헤더` 부분을 마침 보고 있으니 예시로 들겠습니다.

![MDN::HTTP Header 네트워크 탭 예시](https://github.com/kkn1125/kkn1125.github.io/assets/71887242/6d5db9a6-496c-486a-8ab0-a066b131ff1b)

위 이미지는 MDN페이지에서 열어본 네트워크 탭이고, Header 라는 페이지를 요청한 정보를 열람하는 모습입니다.

크게 보면 일반, 응답, 요청 헤더로 나뉩니다. 일반에는 요청 URL, 요청 메서드, 상태 코드, 원격 주소, 리퍼러 정책이 있지요.

이번 포스팅에서는 헤더가 무엇인지 살펴보고, 클라이언트에서 헤더를 읽는 것을 서버에서 제어하는 방법과 요청 시 자동으로 헤더에 담기는 값이 무엇인지 등을 기록하고자 합니다.

## 요청 URL

요청 URL은 사이트에서 요청한 URL입니다. 이때 요청 URL에는 쿼리스트링은 포함 되지만 해시는 포함되지 않습니다. 예를 들면 `http://localhost:3000/?query=test`라고 요청하면 요청 URL은 동일하게 표시 되고, `http://localhost:3000/?query=test#hash`라고 요청하게 되면 해시 값을 제외한 `http://localhost:3000/?query=test`으로 요청 URL이 표기 됩니다.

## 요청 메서드

요청 메서드를 정의하고, 각 종류에 따라 사용하는 목적과 쓰임이 다릅니다. 요청 메서드에는 종류가 다양하며, MDN에 정리된 내용을 빌려 사용되는 메서드는 아래와 같습니다.

1. GET
2. POST
3. PUT
4. DELETE
5. HEAD
6. CONNECT
7. OPTIONS
8. TRACE
9. PATCH

많이 사용하는 메서드는 1 ~ 4, 5, 7 순서로 사용빈도가 높다고 생각합니다. PATCH를 사용하는 것을 본 적은 있지만 많이 사용하지 않은 것으로 알고 있습니다. 각 메서드들은 `안전함`과 `멱등성` 등의 요소로 분류가 되며, 해당 분류는 위 리스트를 간단하게 알고 난 후에 살펴보겠습니다.

### GET 메서드

GET 메서드는 지정된 리소스를 요청하고, 데이터를 검색하는 기능에 주로 사용합니다. 중요한 데이터가 아닌 데이터를 응답하는데 사용되고 안정한 HTTP 메서드에 해당합니다.

### HEAD 메서드

GET 요청과 동일한 응답을 요구하지만, 응답 본문을 포함하지 않는 요청입니다.

### POST 메서드

특정 리소스에 엔티티를 제출할 때 사용됩니다. 서버의 상태 변화나 사이드이펙트를 일으킬 수 있습니다. 여기서 서버의 상태 변화는 POST 요청을 통해 데이터가 수정되거나 추가되는 행위를 통해 발생할 수 있고, 안전하지 않은 HTTP 메서드 호출로 분류됩니다.

### PUT 메서드

PUT 메서드는 목적 리소스 모든 현재 표시를 요청 payload로 변경합니다. 데이터를 수정할 때 자주 사용되는 메서드입니다.

### DELETE 메서드

특정 리소스를 제거하는 목적으로 사용됩니다.

### CONNECT 메서드

목적 리소스로 식별되는 서버로의 터널을 맺는 요청입니다. 사용해 본 적은 없지만 프록시 서버와 관련이 되어 있는 것으로 보이고, 양방향 연결을 시작하는 메소드입니다. 터널을 열기 위해 사용될 수도 있고, SSL을 사용하는 웹사이트에 접속하는데 사용될 수 있으며, 한번 서버에 연결이 수립되면 프록시 서버는 클라이언트에 오가는 TCP 스트림을 프록시 할 수 있다고 합니다. 관련 내용은 포스팅 하단에 첨부 링크를 작성해 두겠습니다.

### OPTIONS 메서드

목적 리소스의 통신을 설정하는 데 사용됩니다. 간혹 서버에 GET 메서드를 제외한 요청을 할 경우 OPTIONS를 설정하지 않았는데도 OPTIONS 요청이 가고 이후에 원하는 메서드 요청이 간 경험이 있을 겁니다. OPTIONS는 CORS와 관련이 있습니다. 만일 서버측에서 허용하는 메서드가 정해져있다면 해당 요청에 대한 허락을 구하는 과정이라고 보시면 됩니다. 요청 시 먼저 OPTIONS를 통해 요청을 보내고(preflight), 메서드가 지원한다면 OPTIONS는 응답 헤더에 Allow라는 속성을 받고, 그에 속하는 메서드면 원래 요청을 했던 메서드로 요청이 갑니다.

### TRACE 메서드

목적 리소스의 경로를 따라 메시지 loop-back 테스트를 합니다. 해당 메서드는 거의 모든 웹 브라우저에서 TRACE를 실행하지 못하도록 제한하고 있다고 합니다. 2003년에 Jeremiah Grossman이 XST 최초 보고서를 내면서 부터 httpOnly 쿠키 탈취 취약점 발견으로 대부분 사이트에서 해당 메서드를 제한하는 것으로 알려져있습니다.

### PATCH 메서드

리소스의 부분만을 수정하는 데 사용하는 요청입니다. PUT 메서드와 유사하지만 차이는 아래와 같습니다.

1. PUT의 경우 리소스의 특정 부분 수정 요청하면 나머지 값은 null값으로 대체된다. 즉, 수정하고자 하는 리소스 데이터를 모두 담은 상태에서 특정 부분만 수정한 데이터가 전송되어야 합니다.
2. PATCH의 경우 리소스 득정 부분 수정 요청하면 해당 부분만 데이터가 교체되고 요청하지 않은 데이터는 그대로 유지된다. 특정 리소스를 변경하는 경우에는 PUT메서드 보다 PATCH메서드를 사용하는 것이 더 효율적으로 네트워크 자원을 사용할 수 있습니다.

## 요청 헤더

이제 요청헤더에 대해 알아봅시다. 요청 헤더에는 의외로 많은 데이터가 오고 가는데요. 주로 보이는 헤더 값은 다음과 같습니다.

1. Accept
2. Accept-Encoding
3. Accept-Language
4. Cache-Control
5. Connection
6. Host
7. Pragma
8. Sec-\*
9. User-Agent
10. Cookie

### Accept\*

`Accept`로 시작하는 속성이 3가지가 있습니다. `Accept`는 요청하는 클라이언트 기준으로 생각하면 됩니다. 클라이언트가 이해 가능한 컨텐츠 타입이 무엇인지를 알려주는 헤더입니다. 이후 응답 헤더에는 서버 측에서 Content-Type 헤더로 클라이언트에게 선택된 타입을 알려줍니다. 예를 들면, 페이지를 요청한다면 응답 헤더에는 `text/html`이, 스크립트 파일이라면 `application/javascript`라는 타입을 헤더로 응답 할 것입니다.

`Accept-Encoding` 헤더는 `gzip`, `deflate`, `br`을 자주 보실겁니다. 이 값은 **"디렉티브"**라 하며 압축 포맷을 나타냅니다. 이 헤더는 클라이언트가 이해 가능한 컨텐츠의 인코딩이 무엇인지를 알려줍니다. `Content-Encoding`을 응답 받거나 `Content-Type`에 타입과 `charset=UTF-8`을 포함하여 응답 받습니다.

`Accept-Language`는 어떤 언어를 클라이언트가 이해 가능한지, 지역 중 어떤 것이 선호되는지 알려주는 부분입니다. 응답으로 `Content-Language`와 함께 응답 받을 수 있습니다. 값 중에 `;q=0.7`이 보이는데 이 값들은 **"인자 가중치"**라고 해서 어느 언어, 지역이 선호되는지에 따라 대체되는 값입니다.

### Host

호스트는 요청한 클라이언트의 호스트를 말합니다.

### Origin

오리진은 요청 클라이언트의 오리진을 나타냅니다.

### Referer

리퍼러는 해당 사이트가 참조되는 경우 작성되는데, 예로는 iframe에서 요청된 페이지의 헤더를 보면 referer된 페이지의 URL을 담게 됩니다. 즉, 현재 요청된 페이지에 대한 링크를 따라가는 이전 웹 페이지의 주소 또는 이미지 또는 기타 리소스를 로드하는 페이지의 주소가 작성되지요. (참고로 iframe의 헤더는 이후 요청할 시 디스크 캐시됩니다.)

그 외 헤더에 대해서는 생략하겠습니다. 많은 헤더가 있지만 주요한 헤더만 짚고 넘어가겠습니다.

## 응답 헤더

오늘 포스팅에서 이야기하고자 하는 주제가 여기에 있습니다. 응답 헤더와 요청 헤더 둘 다 중요하지만 클라이언트는 페이지를 서버로 요청하기 떄문에 응답을 관리하는 서버 측 헤더인 응답 헤더가 둘 중에 매우 중요하다고 생각됩니다.

서버에서 설정하지 않더라도 기본적으로 클라이언트에서 읽을 수 있는 헤더 값은 두 가지 있습니다.

1. Content-Length
2. Content-Type

이 두 가지는 클라이언트에서 읽을 수 있는 값이고, 요청 헤더에서 설명드린 `Content-Type`과 관련이 있지만 없을 수도 있습니다.

이 `Content-Type`에 따라 클라이언트에서는 페이지를 다운로드 할 수도, 읽을 수도 있고, 이미지를 보여주거나 음악 또는 비디오를 재생하는 페이지를 받을 수도 있습니다.

그렇다면 이 외의 헤더를 클라이언트에서 읽을 수 있게 제어하려면 어떻게 해야할까요?

### 클라이언트에서 헤더 값 읽기

클라이언트에서 읽을 수 있는 기본적인 헤더는 두 가지라고 말씀드렸습니다. 그렇다면 다른 값은 어떻게 읽을 수 있을까요? 분명히 서버에서 헤더를 지정하고 보냈고, 개발자 도구로 네트워크 탭을 확인해보면 분명히 값은 있지만 응답에서 값을 읽고자 하면 해당 헤더는 읽지 않습니다.

필자의 경우 node.js를 사용했기 때문에 node.js와 express를 사용하여 예시를 들겠습니다.

```javascript showLineNumbers
const express = require("express");
const app = express();
const cors = require("cors");
const { request } = require("http");

app.use(
  cors({
    origin: "*",
    // allowedHeaders: ["My-Session"],
  })
);
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.get("/", (req, res) => {
  res.setHeader("Access-Control-Expose-Headers", ["my-session"]);
  res.setHeader("my-session", ["test", "wow"]);
  console.log("cookies", req.cookies);
  console.log("heders", req.headers);
  res
    .cookie("test", "foo", {
      domain: "localhost",
      path: "/",
      // httpOnly: true,
      maxAge: 5 * 1000,
    })
    .send("test");
});

app.listen(3000, () => {
  console.log("listening on port 3000");
});
```

위 예시에서 `Access-Control-Expose-Headers`라는 헤더가 등장합니다. 이 헤더는 서버 교차-출처 요청(CORS)에 대한 응답으로 브라우저에서 실행 중인 스크립트가 사용 가능한 응답 헤더를 지정하는 기능을 합니다.

위 소스코드의 예시처럼 `my-session`을 허용하면 헤더에 작성한 `my-session`을 요청한 클라이언트에서 접근하여 특정 헤더값을 읽을 수 있습니다.

```javascript showLineNumbers
app.get("/", (req, res) => {
  // res.setHeader("Access-Control-Expose-Headers", ["my-session"]);
  res.setHeader("my-session", ["test", "wow"]);
  console.log("cookies", req.cookies);
  console.log("heders", req.headers);
  res
    .cookie("test", "foo", {
      domain: "localhost",
      path: "/",
      // httpOnly: true,
      maxAge: 5 * 1000,
    })
    .send("test");
});
```

이렇게 주석처리하고 요청하여 헤더값을 조회해보면 다음과 같습니다.

![읽을 수 있는 기본 헤더 출력](https://github.com/kkn1125/kkn1125.github.io/assets/71887242/f2e876a6-3a72-4bec-a84b-978ed81eb42a)

그렇다면 다시 주석을 해제하고 헤더 값을 등록하면 아래와 같습니다.

```javascript showLineNumbers
app.get("/", (req, res) => {
  res.setHeader("Access-Control-Expose-Headers", ["my-session"]);
  res.setHeader("my-session", ["test", "wow"]);
  console.log("cookies", req.cookies);
  console.log("heders", req.headers);
  res
    .cookie("test", "foo", {
      domain: "localhost",
      path: "/",
      // httpOnly: true,
      maxAge: 5 * 1000,
    })
    .send("test");
});
```

![추가 허용된 my-session 헤더](https://github.com/kkn1125/kkn1125.github.io/assets/71887242/0f69a029-90d7-4520-858a-497c3416283f)

그러면 모든 헤더를 읽어오고 싶을때는 어떻게 해야할까요? Expose 헤더의 값에 `"*"`를 입력해서 모든 헤더를 읽기 가능하게 할 수 있습니다.

```javascript showLineNumbers
app.get("/", (req, res) => {
  res.setHeader("Access-Control-Expose-Headers", "*");
  res.setHeader("my-session", ["test", "wow"]);
  console.log("cookies", req.cookies);
  console.log("heders", req.headers);
  res
    .cookie("test", "foo", {
      domain: "localhost",
      path: "/",
      // httpOnly: true,
      maxAge: 5 * 1000,
    })
    .send("test");
});
```

![모두 허용된 헤더](https://github.com/kkn1125/kkn1125.github.io/assets/71887242/732c06ec-30a2-4be0-888c-6d10109c4467)

모든 헤더 값을 읽어 올 수 있게 되었습니다. 이미지에서 보이는 Set-Cookie의 경우는 서버 환경(Node.js)에서 사용하기 위한 것이고, 브라우저에서 노출된 모든 응답에서는 네트워크를 통해 검색된 결과에서 필터링되기 때문에 빈 배열로 표기되는 부분은 참고바랍니다.

## 마무리

사실 응답 헤더의 `Access-Control-Expose-Headers`를 기록하기 위해 시작한 포스팅이 헤더의 기본을 이해하는 글로 바뀌었습니다. 하나의 글만 달랑 적기도 그렇고 해서 찾다보니 XST라는 공격에 대한 방어를 알게 되었고, 사용하지 않던 HTTP Method와 각 요청 별 정확한 의미와 목적, 쓰임을 알게 된 좋은 계기라 생각합니다. 하나의 지식을 공유하기 위해 오히려 자기개발한 느낌이 들어 뿌듯합니다.

부족한 내용과 필력으로 인해 글의 완성도가 떨어지지만 내용은 주기적으로 공부한 내용을 업데이트하며 보완해 나갈 예정입니다.

여기까지 읽어주셔서 감사합니다. 마치며 아래 첨부된 링크도 함께 보면 좋을 것 같습니다 😁

---

📚 함께 보면 좋은 내용

[Jeremiah Grossman - XST 최초 보고서](https://www.cgisecurity.com/whitehat-mirror/WhitePaper_screen.pdf)

[MDN - Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers)

[MDN - HTTP Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)

[MDN - Cacheable](https://developer.mozilla.org/ko/docs/Glossary/Cacheable)

[MDN - HTTP Cookie](https://developer.mozilla.org/docs/Web/HTTP/Cookies)

[MDN - Referer](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer)

[MDN - Referer header](https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns)

[MDN - CONNECT Method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT)

[MDN - Proxy server](https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server)

[홈페이지 취약점 분석 이야기 - TRACE와 XST(Cross-site Tracing) 공격](https://webhack.dynu.net/?idx=20161111.001)
