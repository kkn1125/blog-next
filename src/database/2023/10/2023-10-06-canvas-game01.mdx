---
slug: "/canvas-game01/"
date: 2023-10-06 13:42:28 +0000
modified: 2023-10-06 13:42:28 +0000
title: "[JAVASCRIPT] 게임 모방하고 제작하기 01"
author: Kimson
categories: [game]
image: https://github.com/kkn1125/kkn1125.github.io/assets/71887242/af2aa4c1-c4b6-4763-8f40-772a47f6a70c
tags: [game, javascript, canvas, animal-match, promise, til]
description: "모방 할 게임 찾기

여유 시간을 가질 때면 항상 무언가를 만들기 위해서 찾아보고 직접 구현하는 시간을 가졌습니다. 그림을 그리거나 악보를 보며 기타를 치는 취미처럼 프로그램을 만들어 가지고 놀거나 지인에게 배포하여 함께 공유하기도 합니다. 지금까지도 그러고 있습니다.

이제까지 생각만 했던 게임을 만들어보고자 했습니다. 해당 게임은 위메이드플레이에서 개발, 유통한 모바일 게임입니다. 친구들과 순위로 경쟁도하고 스팸같은 하트 메세지도 남발했습니다 🤔

모방할 게임을 선정하고 필자가 사용하는 언어와 지식으로 제작해보고자 했습니다. 막연하게 \"만들어 봐야지\"로 시작했다가 완성하긴했지요.

게임 규칙 파악하기

모방하고자 하는 게임은 셀 수도 없을 만큼 많을 수 있습니다. 어떤 게임이 됐건 간에 만들어보고 시행착오를 겪으면서 기술을 이해하는데 목적이 있는 것이기 때문에 부담가질 필요도, 좌절할 필요도 없다고 생각합니다.

모방할 게임은 애니팡입니다. 애니팡을 기준으로 규칙을 나열해봅시다."
featured: true
rating: 4.5
profile: false
published: true
---

# 모방 할 게임 찾기

여유 시간을 가질 때면 항상 무언가를 만들기 위해서 찾아보고 직접 구현하는 시간을 가졌습니다. 그림을 그리거나 악보를 보며 기타를 치는 취미처럼 프로그램을 만들어 가지고 놀거나 지인에게 배포하여 함께 공유하기도 합니다. 지금까지도 그러고 있습니다.

이제까지 생각만 했던 게임을 만들어보고자 했습니다. 해당 게임은 위메이드플레이에서 개발, 유통한 모바일 게임입니다. 친구들과 순위로 경쟁도하고 스팸같은 하트 메세지도 남발했습니다 🤔

모방할 게임을 선정하고 필자가 사용하는 언어와 지식으로 제작해보고자 했습니다. 막연하게 "만들어 봐야지"로 시작했다가 완성하긴했지요.

## 게임 규칙 파악하기

모방하고자 하는 게임은 셀 수도 없을 만큼 많을 수 있습니다. 어떤 게임이 됐건 간에 만들어보고 시행착오를 겪으면서 기술을 이해하는데 목적이 있는 것이기 때문에 부담가질 필요도, 좌절할 필요도 없다고 생각합니다.

모방할 게임은 애니팡입니다. 애니팡을 기준으로 규칙을 나열해봅시다.

1. 9 X 9 사이즈의 판이 주어지고, 각 셀에는 랜덤한 동물이 배치된다.
2. 동물을 클릭하고, 클릭된 동물의 사방으로 1칸에 인접한 동물을 다시 클릭하면 자리를 바꾼다.
3. 같은 동물들이 3개 이상 나열되면 해당 동물들이 사라지고 점수를 얻는다.
4. 사라진 동물 자리는 해달 열의 동물들이 아래 방향으로 내려와 자리를 채우고 빈 칸의 개수만큼 랜덤한 동물이 맨 위에서 내려온다.
   - 만일, 자리를 채운 후 3개 이상 같은 동물이 나열된다면 3번을 반복한다.
   - 만일, 동물을 이동하여 3개이상 나열할 경우의 수가 없다면 맵을 새로 생성한다.
5. 주어진 턴 수 내에 게임을 클리어 한다.
6. 최종으로 얻은 점수를 기록한다.

여기까지가 기본적인 규칙이라고 생각했습니다. 그 다음 재미 요소를 더하고자 아이템의 개념을 넣고, 퀘스트를 넣어 보상하거나 콤보를 넣어 가산 점수를 주는 장치를 추가했습니다.

## 게임 추가 규칙 추가하기

게임 추가 규칙은 다음과 같습니다.

1. 퀘스트
   - 랜덤한 퀘스트가 2개까지 주어지고, 특정 동물을 매치하여 목표된 동물 수를 달성하면 보상을 얻는다.
   - 보상의 종류는 추가 점수와 추가 턴 수로 한다.
2. 아이템
   - 아이템을 총 3가지로 하며, 아이템 사용방법은 두 가지로 한다.
   - 사방의 열을 사라지게 하고 점수를 얻는 아이템
   - 수직열을 사라지게 하고 점수를 얻는 아이템
   - 수평열을 사라지게 하고 점수를 얻는 아이템
   - 아이템을 클릭 시 위와 같이 기능하고, 동물을 선택하고 아이템과 자리 바꿈 시 해당 동물의 자리에서 해당 아이템 효과를 적용
3. 콤보
   - 콤보가 5, 10, 50, 100을 각각 초과하면 2배, 3배, 4배, 5배 까지 점수가 가산되고, 퀘스트 보상 점수 및 동물 매치 시 얻는 점수에 일괄 적용

이제 규칙을 정했으니 게임 코어와 필요한 모듈을 제작하면 됩니다. 다른 게임 제작은 어떨지 모르지만 필자는 `JavaScript`를 사용하여 게임을 만들 것이기 때문에 다소 노가다가 필요했습니다.

## 게임 코어와 모듈 제작하기

게임 코어는 곧 엔진이 되겠습니다. 파일 구조는 다음과 같이 구성했습니다.

```plaintext
└┬  📂 root/                     --- 루트
 ├┬  📂 public/
 │└─  📄 favicon...              --- 파비콘 이미지
 ├┬  📂 src/                     --- 핵심 디렉토리
 │├┬  📂 assets/
 ││├┬  📂 animals/               --- 동물 얼굴 이미지 모음
 │││├─  📄 dog.png               --- 강아지 얼굴 이미지
 │││└─  📄 <others...>           --- 다른 동물 얼굴 이미지
 ││└┬  📂 style/
 ││ └─  📄 main.scss             --- 메인 스타일
 │├┬  📂 model/                  --- 모델 객체
 ││├─  📄 cell.ts                --- 셀 객체
 ││└─  📄 quest.ts               --- 퀘스트 객체
 │├┬  📂 service/                --- 게임 엔진 및 모듈
 ││├─  📄 base.module.ts         --- 모든 객체 기본 상속 객체
 ││├─  📄 block.manager.ts       --- 게임 규칙을 판별 조작하는 비즈니스 모듈
 ││├─  📄 game.core.ts           --- 모듈을 제어하는 컨트롤 모듈 (엔진)
 ││├─  📄 map.generator.ts       --- 맵을 생성, 초기화하는 모듈
 ││├─  📄 pointer.ts             --- 마우스 커서 이벤트를 조작하는 모듈
 ││├─  📄 quest.manager.ts       --- 퀘스트를 관리하는 모듈
 ││├─  📄 score.calculator.ts    --- 점수를 관리하는 모듈
 ││└─  📄 store.manager.ts       --- 사용자 게임 정보를 기록하는 모듈
 │├┬  📂 util/                   --- 전역 사용 변수 및 함수 모음
 ││├─  📄 base.logger.ts         --- 커스텀 로거 상속 객체
 ││├─  📄 global.ts              --- 전역 변수 모음
 ││├─  📄 logger.ts              --- 커스텀 로거 객체
 ││└─  📄 tool.ts                --- 전역 함수 모음
 │└─  📄 main.ts                 --- 게임 시작 핵심 파일
 ├─  📄 .env                     --- 기본 환경변수
 ├─  📄 .env.development         --- 개발용 환경변수
 ├─  📄 babel.config.json        --- 바벨 설정
 ├─  📄 jest.config.ts           --- jest 설정
 ├─  📄 package.json
 └─  📄 tsconfig.json            --- 타입스크립트 설정
```

개인적으로 손그림이 편해서 초기에는 손그림으로 표현하기도 했습니다. 손그림으로 필요한 모듈과 각 모듈이 수행할 기능을 분류하는데 초점을 맞추었습니다. 막상 제작하는 과정에서 사라진 모듈도 있지만 현재 만들어진 게임을 기준으로 포스팅하겠습니다.

## 무엇을 먼저 제작해야하나?

제일 먼저 했던 작업은 기본 조작을 위해 필수였던 맵 제작과 마우스 포인터가 제작된 맵의 셀을 클릭하여 동물을 식별하는 작업이었습니다.

먼저 맵이 있어야 포인터가 인식할수 있으니 맵을 제작할텐데요. 맵을 제작 하기에 앞서 선수지식이 필요합니다.

사용할 것은 `JavaScript`의 `canvas element`입니다. `canvas`를 사용하고 최적화하는 방법은 `MDN`에 친절하게 설명되어 있기 때문에 자세한 설명은 생략하고 필요한 것만 짚고 넘어가겠습니다.

우선 적용해야한 방식은 `canvas`를 레이어로 겹쳐 사용하는 것입니다. 이는 캔버스를 단일로 돌릴 때 보다 부하가 절감되기 때문에 여러 레이어를 만들어 겹치는 방식으로 적용하였고, 표현되는 애니메이션이 잘못 조정하면 원하는 효과가 원하지 않는 효과 뒤에 숨어서 보이지 않는 경우도 방지합니다.

### 게임 코어 설정과 레이어 전략

캔버스를 겹치는 전략은 다음과 같습니다.

1. map layer
2. bg layer
3. score layer
4. quest layer
5. select layer
6. effect layer

이렇게 6개의 레이어를 운용하겠습니다. 1번이 제일 밑에 깔리고, 6번이 제일 위로 뜨는 형태입니다.

초기에 `canvas`를 생성하면 6개의 `canvas`를 생성해야겠지요.

```typescript showLineNumbers
// src/service/game.core.ts

import Logger from "@src/util/logger";
import BaseModule from "./base.module";
import BlockManager from "./block.manager";
import MapGenerator from "./map.generator";
import Pointer from "./pointer";
import QuestManager from "./quest.manager";
import ScoreCalculator from "./score.calculator";
import StoreManager from "./store.manager";
import {
  mapCanvas,
  bgCanvas,
  scoreCanvas,
  questCanvas,
  selectCanvas,
  effectCanvas,
} from "@src/util/global.ts";

export default class GameCore extends BaseModule {
  blockManager: BlockManager;
  mapGenerator: MapGenerator;
  scoreCalculator: ScoreCalculator;
  storeManager: StoreManager;
  pointer: Pointer;
  questManager: QuestManager;
  logger: Logger;

  canvases: HTMLCanvasElement[] = [];

  constructor() {
    this.blockManager = new BlockManager();
    this.mapGenerator = new MapGenerator();
    this.scoreCalculator = new ScoreCalculator();
    this.storeManager = new StoreManager();
    this.pointer = new Pointer();
    this.questManager = new QuestManager();
    this.logger = new Logger();

    this.canvases.push(
      mapCanvas,
      bgCanvas,
      scoreCanvas,
      questCanvas,
      selectCanvas,
      effectCanvas
    );
  }
}
```

게임 코어에서 여러 모듈을 제어할 수 있어야 하기 때문에 모든 모듈을 게임 코어의 프로퍼티로 선언하고 초기화 시 정의해줍니다.

마지막 프로퍼티에 `canvas`를 담는 배열이 있습니다. 해당 배열에 위에서 나열했던 레이어 전략 순서로 `canvas`를 집어 넣습니다.

```typescript showLineNumbers
// src/util/global.ts

export const createCanvas = (id?: string) => {
  const canvas = document.createElement("canvas") as HTMLCanvasElement;

  const ctx = canvas.getContext("2d", {
    desynchronized: false,
    alpha: true,
    willReadFrequently: false,
  }) as CanvasRenderingContext2D;
  if (id) {
    canvas.id = id;
  }
  return [canvas, ctx] as [HTMLCanvasElement, CanvasRenderingContext2D];
};

export const [mapCanvas, mapCtx] = createCanvasAndContext("map-layer");
export const [bgCanvas, bgCtx] = createCanvasAndContext("bg-layer");
export const [scoreCanvas, scoreCtx] = createCanvasAndContext("score-layer");
export const [questCanvas, questCtx] = createCanvasAndContext("quest-layer");
export const [selectCanvas, selectCtx] = createCanvasAndContext("select-layer");
export const [effectCanvas, effectCtx] = createCanvasAndContext("effect-layer");

document.body.append(
  mapCanvas,
  bgCanvas,
  scoreCanvas,
  questCanvas,
  selectCanvas,
  effectCanvas
);
```

### 게임 맵 제작

게임 맵 제작은 이 게임을 제작하는 과정 중 제일 편하다고 생각됩니다. 그저 랜덤으로 돌려주면 맵은 제작됩니다. 하지만 맵이 제작되었다고 해서 맵 제작이 끝난게 아니지요. 초기 시작에서 3열 이상 매치되버리면 게임의 공정성이 깨지니까요. 누구는 더 많은 동물이 매치되어 시작점수가 다르면 안되잖아요?

```typescript showLineNumbers
// src/util/global.ts

type BlockTypeNScore = [string, number];

export const BASE_TYPE_SCORE: BlockTypeNScore[] = [
  ["dog", 1],
  // ["cat", 2], // 개체 수 조정하여 난이도 조절
  ["duck", 3],
  ["mouse", 4],
  // ["rabbit", 5], // 개체 수 조정하여 난이도 조절
  ["lion", 6],
  ["pig", 7],
  ["panda", 8],
  ["racoon", 9],
  // ["horizon", 0], // 이후 추가될 아이템
  // ["vertical", 0], // 이후 추가될 아이템
  // ["all", 0], // 이후 추가될 아이템
];
```

맵 제작에 필요한 셀의 타입과 점수를 정의하는 변수를 `global.ts`에 정의해줍니다. 그 다음 맵 제작에 필요한 메서드를 정의합니다.

```typescript showLineNumbers
// src/service/map.generator.ts

import Cell from "@src/model/cell";
import Logger from "@src/util/logger";
import BaseModule from "./base.module";
import { BASE_TYPE_SCORE } from "@src/util/global";

export default class MapGenerator extends BaseModule {
  types = BASE_TYPE_SCORE;
  map: Cell[][] = [];
  mapSize: [number, number] = [0, 0];
  logger: Logger;

  constructor(
    mode: string,
    x: number = OPTIONS.WIDTH.GAME.X,
    y: number = OPTIONS.WIDTH.GAME.Y
  ) {
    super(mode);
    this.logger = new Logger(this.constructor.name);
    this.logger.dir("constructor").log("initialize mode:", mode);
    this.mapSize = [x, y];
    this.initialize(this.createMap(this.mapSize));
  }

  initialize(map: Cell[][]) {
    this.logger.dir("initialize").log("get created map", map);
    this.map = map;
  }

  createMap([xSize, ySize]: Axis) {
    const maps: Cell[][] = [];
    for (let y = 0; y < ySize; y++) {
      const cells: Cell[] = [];
      for (let x = 0; x < xSize; x++) {
        const [type, score] = this.getRandomCellType();
        cells.push(new Cell(type, x, y, score));
      }
      maps.push(cells);
    }
    return maps;
  }

  getRandomCellType() {
    const onlyAnimals = this.types;
    const randomTypeIndex = Math.floor(Math.random() * onlyAnimals.length);
    return onlyAnimals[randomTypeIndex];
  }
}
```

맵 제작 모듈은 맵을 생성하고, 초기화하는 역할만 수행하도록 합니다. 부득이한 경우가 아니면 메서드의 재사용성을 높이기 위해서 기본값이나 적용되는 값은 인자로 받아 사용하게 만듭니다.

`createMap`의 인자로 `x`와 `y`의 길이(사이즈) 값을 주고 `getRandomCellType` 메서드로 사용해서 랜덤한 셀의 타입과 점수를 받아 셀을 생성합니다.

생성된 2차 배열의 셀을 반환합니다. 반환된 맵 데이터는 생성자가 호출될 때 `initialize` 메서드를 통해 초기화 되며 `map`프로퍼티에 정의됩니다.

여기서 3개 이상 나열된 동물이 있으면 동물을 바꾸거나 맵을 새로 생성해야 합니다. 맵을 새로 생성하기 보다는 3개로 나열되는 경우만 골라서 동물을 변경하는 게 좋을 수 있겠지요.

로직은 만들기 나름이니 개별적으로 풀어보시기 바랍니다. 재미로 만드는 거라 굳이 안해도 되지만요 😁

### 게임 맵 중앙 맞추기

맵을 중앙으로 맞추기 위해 기존에 작성한 `MapGenerator` 모듈에 메서드를 추가합니다. 추가하는 메서드는 render 메서드이고 게임 코어에서 사용될 예정이며, 컬러가 필요합니다.

```typescript showLineNumbers
// src/util/global.ts

// variables ...

export const BG_COLOR = "#dddddd";
export const CELL_OUTLINE_COLOR = "#565656";

export const isMobile = () =>
  !!window.navigator.userAgent.match(/android|mobile/gi);

export const SUB_OPTIONS = {
  SIZE: {
    RATIO: 1,
  },
};

export const OPTIONS = {
  SIZE: {
    // 셀 크기
    UNIT: 50,
  },
  ITEM: {
    // 동물 매치 최소 값
    MATCH_LIMIT: 3,
  },
  WIDTH: {
    GAME: {
      // 게임 크기
      X: 9,
      Y: 9,
    },
  },
  ANIMATION: {
    SPEED: isMobile() ? 0.13 : 0.1, // 게임 속도
    FRAME: 16, // 게임 프레임 수 (높을수록 끊김, 낮을수록 부드러움)
  },
  GAME: {
    TURN: 75, // 게임 초기 턴 수
    HINT: RUN_MODE === "test" ? Infinity : 5, // 게임 힌트 개수
  },
};

export const RESPONSIVE_UNIT_SIZE = () =>
  OPTIONS.SIZE.UNIT + SUB_OPTIONS.SIZE.RATIO;
```

사용할 색상을 미리 정의하고 맵 제작 모듈로 갑니다.

```typescript showLineNumbers
// src/srevice/map.generator.ts

import Cell from "@src/model/cell";
import Logger from "@src/util/logger";
import BaseModule from "./base.module";
import {
  bgCtx,
  mapCtx,
  CELL_OUTLINE_COLOR,
  BG_COLOR,
  OPTIONS,
  RESPONSIVE_UNIT_SIZE,
} from "@src/util/global";

export default class MapGenerator extends BaseModule {
  types = BASE_TYPE_SCORE;
  map: Cell[][] = [];
  mapSize: [number, number] = [0, 0];
  logger: Logger;

  // ... methods

  render() {
    mapCtx.fillStyle = BG_COLOR + "b6";
    mapCtx.fillRect(0, 0, innerWidth, innerHeight);
    if (this.mode === "test") {
      mapCtx.strokeStyle = CELL_OUTLINE_COLOR + "26";

      for (const row of this.map) {
        for (const cell of row) {
          const [x, y] = responseBlockAxis(
            cell.x * RESPONSIVE_UNIT_SIZE(),
            cell.y * RESPONSIVE_UNIT_SIZE()
          );
          mapCtx.strokeRect(
            x,
            y,
            RESPONSIVE_UNIT_SIZE(),
            RESPONSIVE_UNIT_SIZE()
          );
        }
      }

      mapCtx.strokeStyle = CELL_OUTLINE_COLOR;
    }

    bgCtx.fillStyle = BG_COLOR;
    // top, bottom
    bgCtx.fillRect(
      0,
      0,
      innerWidth,
      (innerHeight - OPTIONS.WIDTH.GAME.Y * RESPONSIVE_UNIT_SIZE()) / 2
    );
    bgCtx.fillRect(
      0,
      OPTIONS.WIDTH.GAME.Y * RESPONSIVE_UNIT_SIZE() +
        (innerHeight - OPTIONS.WIDTH.GAME.Y * RESPONSIVE_UNIT_SIZE()) / 2,
      innerWidth,
      (innerHeight - OPTIONS.WIDTH.GAME.Y * RESPONSIVE_UNIT_SIZE()) / 2
    );
    // both-side
    bgCtx.fillRect(
      0,
      0,
      innerWidth / 2 - (OPTIONS.WIDTH.GAME.X * RESPONSIVE_UNIT_SIZE()) / 2,
      innerHeight
    );
    bgCtx.fillRect(
      innerWidth / 2 -
        (OPTIONS.WIDTH.GAME.X * RESPONSIVE_UNIT_SIZE()) / 2 +
        OPTIONS.WIDTH.GAME.X * RESPONSIVE_UNIT_SIZE(),
      0,
      innerWidth / 2 - (OPTIONS.WIDTH.GAME.X * RESPONSIVE_UNIT_SIZE()) / 2,
      innerHeight
    );
  }
}
```

렌더링할 때 먼저 맵을 mapCtx로 표현합니다. 그다음 상위 레이어인 `bg-layer`에 맵을 제외한 나머지 공간을 색으로 채워 가립니다. 이유는 이후 동물 3개 이상 매치 후 사라진 공간에 수직으로 떨어지면서 랜덤으로 채워질 셀이 맵 바깥에서 생성되기 때문인데요.

![예시](https://github.com/kkn1125/kkn1125.github.io/assets/71887242/27543843-9e28-4357-be1c-0eecd966b98f)

모두 생성 후 떨어뜨리는 로직을 구현하기 위해서 맵을 초과하여 생성되는 셀이 위 이미지처럼 보기 좋지 않기 때문입니다. 맵 끝에서 보이지 않게 생성되어 자연스럽게 무한히 연장되어 보이도록 하기 위함이지요.

### 포인터 구현

마우스 이벤트는 `DOM`에서 제공되는 요소를 모두 제어할 수 있지만 캔버스의 경우 계산이 필요합니다. 이미 중앙으로 이동시킨 맵의 셀을 선택해야하기 때문에 맵의 중앙으로 이동한 값에서 좌표의 차를 구하여 각 위치의 포인터가 정확하게 셀의 동물을 인식할 수 있어야 게임에 버그가 없고 원활한 게임 제작이 됩니다.

포인터에서 사용할 중앙값과 부수적인 함수를 만들고 난 후 포인터 모듈로 갑시다.

```typescript showLineNumbers
export const capitalize = (str: string) =>
  str.charAt(0).toLowerCase() + str.slice(1);

export const responseBlockAxis = (x: number, y: number) => {
  const centerX = innerWidth / 2;
  const centerY = innerHeight / 2;
  const horizonValue = OPTIONS.WIDTH.GAME.X * RESPONSIVE_UNIT_SIZE();
  const verticalValue = OPTIONS.WIDTH.GAME.Y * RESPONSIVE_UNIT_SIZE();
  const halfHorizon = horizonValue / 2;
  const halfVertical = verticalValue / 2;
  const resX = centerX + x - halfHorizon;
  const resY = centerY + y - halfVertical;
  return [resX, resY];
};

export const responsePointerAxis = (x: number, y: number): [number, number] => {
  const centerX = innerWidth / 2;
  const centerY = innerHeight / 2;
  // const unitX = Math.floor(x / this.unit);
  // const unitY = Math.floor(y / this.unit);
  const horizonValue = OPTIONS.WIDTH.GAME.X * RESPONSIVE_UNIT_SIZE();
  const verticalValue = OPTIONS.WIDTH.GAME.Y * RESPONSIVE_UNIT_SIZE();
  const halfHorizon = horizonValue / 2;
  const halfVertical = verticalValue / 2;

  // const [resX,resY]=responseAxis(x,y)

  const unitCenterX = Math.floor(
    (x - centerX + halfHorizon) / RESPONSIVE_UNIT_SIZE()
  );
  const unitCenterY = Math.floor(
    (y - centerY + halfVertical) / RESPONSIVE_UNIT_SIZE()
  );
  return [unitCenterX, unitCenterY];
};

export const wait = [];
```

`capitalize` 함수는 첫 문자 대문자의 카멜케이스를 얻기 위한 함수이고, `responseBlockAxis`는 반응형을 고려한 블록 단위의 인덱스를 얻는 함수, `responsePointerAxis`는 반응형을 고려한 포인터 위치의 x, y 값을 얻습니다. PointerAxis는 정수값이고, BlockAxis는 소수점이라는 차이가 있습니다. 이 함수들은 이후에도 재사용되기 때문에 전역 변수로 뽑아두었습니다. `wait` 는 클릭 후 애니메이션하는 동안 클릭을 방지하기 위한 배열입니다. 클릭 시 `wait`에 값이 들어가고 `wait`에 값이 있을 때는 클릭을 막고 애니메이션이 끝나고 프로미스를 반환하면 `wait`값을 제거하는 방식입니다.

```typescript showLineNumbers
// src/srevice/pointer.ts

import Cell from "@src/model/cell";
import { wait } from "@src/util/global";
import Logger from "@src/util/logger";
import { capitalize, responsePointerAxis } from "@src/util/tool";
import BaseModule from "./base.module";
import BlockManager from "./block.manager";
import MapGenerator from "./map.generator";
import ScoreCalculator from "./score.calculator";
import { Dependency } from "./types";

export default class Pointer extends BaseModule {
  logger: Logger;
  dependency: Dependency = {};
  grab: Cell | null = null;
  swapTemp: Cell[] = [];
  gameEnd: boolean = false;

  constructor() {
    this.logger = new Logger(this.constructor.name);
    this.logger.dir("constructor").log("initialize mode:", mode);

    window.addEventListener("mousemove", this.moveMouse.bind(this));
    window.addEventListener("mousedown", this.clickCell.bind(this));
  }

  async clickCell() {
    this.logger.dir("clickCell").dir("debug wait").debug("!!!!!!!!wait", wait);
    if (wait.length > 0) {
      this.logger.dir("clickCell").error("current working click event", wait);
      this.swapTemp = [];
      return;
    }

    if (this.grab) {
      this.logger.dir("clickCell").debug(this.grab);

      if (this.swapTemp.length < 2) {
        this.grab.isSelected = true;
        this.swapTemp.push(this.grab);
        this.logger.dir("clickCell").log(this.swapTemp);
        this.logger
          .dir("clickCell")
          .dir("select first cell")
          .debug(this.swapTemp[0]);
      }

      if (this.swapTemp.length === 2) {
        this.logger.dir("clickCell").log(this.swapTemp);
        this.logger.dir("clickCell").log("this.swapTemp length", 2);

        if (
          this.dependency.blockManager &&
          this.swapTemp[0] !== this.swapTemp[1] &&
          wait.length === 0
        ) {
          this.logger
            .dir("clickCell")
            .dir("select second cell")
            .debug(this.grab);

          // commit
          wait.push(0);
          this.logger.dir("clickCell").log("swap both run");
          const isBoundary = this.dependency.blockManager.isInBoundary(
            this.swapTemp[0],
            this.swapTemp[1]
          );
          this.logger.dir("clickCell").debug("isBoundary", isBoundary);

          if (isBoundary) {
            this.dependency.scoreCalculator?.turnCount();
          }
          try {
            const isSwapped = await this.dependency.blockManager.swapBothCell(
              this.swapTemp[0],
              this.swapTemp[1]
            );

            if (!isSwapped) {
              this.logger.dir("swapBothCellAndFill").error("not swapped");
              if (isBoundary) {
                this.dependency.scoreCalculator?.divideCombo();
              }
              const first =
                this.dependency.blockManager.map?.[this.swapTemp[0]?.y]?.[
                  this.swapTemp?.[0]?.x
                ];
              const second =
                this.dependency.blockManager.map?.[this.swapTemp[1]?.y]?.[
                  this.swapTemp?.[1]?.x
                ];
              await this.dependency.blockManager.revertSwap(first, second);
              await this.dependency.blockManager.autoPangAndFill();

              // release
              wait.pop();

              this.swapTemp[0] && (this.swapTemp[0].isSelected = false);
              this.swapTemp[1] && (this.swapTemp[1].isSelected = false);

              this.swapTemp = [];

              return;
            }
          } catch (error) {
            return;
          }

          await this.dependency.blockManager.autoPangAndFill();
          this.logger.dir("clickCell").debug("release??");
          // release
          wait.pop();

          this.swapTemp[0] && (this.swapTemp[0].isSelected = false);
          this.swapTemp[1] && (this.swapTemp[1].isSelected = false);
          this.logger.dir("clickCell").log("swap both end");
        }

        this.logger.dir("clickCell").log(this.swapTemp);
        this.swapTemp[0] && (this.swapTemp[0].isSelected = false);
        this.swapTemp[1] && (this.swapTemp[1].isSelected = false);
        this.swapTemp = [];
        this.logger.dir("clickCell").log(this.swapTemp);
      }
      this.logger.dir("clickCell2").debug(this.swapTemp);
    } else {
      this.logger.dir("clickCell").debug("no grab");
    }
    this.logger
      .dir("clickCell")
      .debug("map", this.dependency.blockManager?.map);
  }

  moveMouse(e: MouseEvent) {
    const x = e.clientX;
    const y = e.clientY;
    const [resX, resY] = responsePointerAxis(x, y);
    try {
      if (this.gameEnd) {
        throw new Error("the game end");
      }
      const cell = this.getCellInfo(resX, resY);
      this.grab = cell;
      if (cell) {
        //
      }
      if (!this.grab.isHover) {
        this.grab.isHover = true;
      }
    } catch (error) {
      this.grab = null;
    }
  }

  getCellInfo(x: number, y: number): never | Cell {
    if (this.dependency.mapGenerator) {
      const cell = this.dependency.mapGenerator.map?.[y]?.[x];
      if (cell) {
        return cell;
      }
      throw new Error("not found cell");
    } else {
      throw new Error("no injected module");
    }
  }
}
```

`mousemove` 이벤트는 마우스를 움직일때는 어느 위치에 있고, 해당 위치에 있는 셀을 임시 공간에 담기위함이고, `mousedown` 이벤트는 현재 마우스 포인트가 있는 곳에 동물을 클릭하거나 취소하는 기능을 위해 작성됩니다.

에러를 확인하기 위해 `logger`와 `throw`를 많이 사용했습니다. 이후에 기능을 추가하거나 제거할 때 디버깅에 도움이 많이 됩니다 😀

먼저, 포인터의 위치값을 맵이 시작하는 끝 모서리가 `0, 0` 좌표가 뜨도록 연산하여 맞춰야 합니다. 미리 만들어둔 `responsePointerAxis` 전역 함수로 `clientX`, `clientY` 값을 인자로 넘겨 연산된 포인터 위치 값을 반환 받습니다. 그러면 마우스가 움직일 때마다 해당 포인터 좌표에 셀이 있는지 없는지 판별하고 `grab` 프로퍼티에 셀을 저장합니다.

`grab`에 저장된 상태로 클릭하게 되면 `clickCell` 메서드가 비동기로 실행됩니다. `swapTemp`는 튜플형태로 클릭한 셀을 저장하며, 2개 선택 시 자리 교체를 하도록 하고, 1개 선택 후 동일한 셀을 선택한다면 모든 `swapTemp`를 비웁니다.

만일, `wait` 배열에 값이 있다면 클릭을 방지하도록 분기문을 통해 `return`시키고, 셀을 두번 째 클릭할 때 `wait`가 비어있는 경우 `wait`에 임의 값을 넣어 클릭을 블록시키고, 자리 교체하는 애니메이션과 매치되어 사라지는 애니메이션, 빈 자리를 채우는 애니메이션이 완료될 때까지 대기한 후 `wait`를 초기화하고 클릭을 대기합니다.

교체했는데 동물이 매치되지 않으면 다시 원위치로 돌려야합니다. 그렇지 않으면 동물을 이동시켜 매치시키게 되니 난이도가 매우 낮아지겠지요.

위 코드를 보면 `revertSwap`이라는 메서드가 있는데 교체한 동물을 원위치로 돌리는 메서드입니다.

`autoPangAndFill`메서드를 공개하자니 재사용을 위해 만든 여러 조각의 메서드가 조합된 메서드라서 모두 공개하기엔 글이 너무 길어져 애니메이션과 비동기 처리했던 것을 아래에 정리하고자 합니다.

비동기에 대해 아시는 분이라면 더 많은 방법을 아시겠지만 이제 막 접하시는 분들에게 도움이나마 되면 좋겠네요.

```typescript
const MOVE_SPEED = 2;
const FRAME = 16;

function swapAnimation(srcCell: Cell, dstCell: Cell) {
  let resolver: (value: unknown) => void;
  const promise = new Promise((resolve) => (resolver = resolve));
  const direction = srcCell.y > dstCell.y ? -1 : 1;
  const animationLoop = setInterval(() => {
    srcCell.moveY(direction * MOVE_SPEED);
    if (direction > 0 && srcCell.y <= dstCell.y) {
      clearInterval(animationLoop);
      resolver(true);
    }
    if (direction < 0 && srcCell.y >= dstCell.y) {
      clearInterval(animationLoop);
      resolver(true);
    }
  }, FRAME);
  return promise;
}

async function render() {
  console.log("render start");
  await swapAnimation();
  console.log("render end");
}
```

`Promise` 인스턴스를 생성할 때 `resolve`를 밖으로 빼고 `promise`를 반환시킵니다. 그리고 원하는 값에 도달하거나 일정 시간 후 `resolver`에 값을 전달하면 해당 함수를 쭉 기다렸다가 "render end"라는 로그를 남깁니다. 이 방법을 통해서 모방하고자 했던 애니팡을 조금이나마 따라 만들었고, 현재는 랭킹 시스템을 남기고 개인적인 일정 때문에 중단한 상태입니다.

## 마무리

다른 모듈을 제작하는 과정을 소개드리고 싶었지만 모든 과정을 기록하기 보다는 게임을 모방하는 과정에서 얻은 이해와 방법을 간단하게 소개하는 것으로 마치는게 좋을 것 같다는 생각입니다. 무작정 블로그를 이리저리 둘러보면서 그대로 따라하기 보다 스스로 생각해서 구현하는게 훨씬 얻는게 많으니까요🤔

바쁜 시기를 지나면서 잠시나마 휴식도하고 재미를 본 작업이었습니다. 이후에 게임들이 여럿 모이면 광고없는 미니게임으로 애플리케이션으로 만들어 지인들에게 배포할 예정입니다😁

아래는 현재 블로그에도 새로운 페이지를 만들어 제공하고 있지만 이번 포스팅 마무리로 게임을 소개하면서 마치겠습니다. 여기까지 읽어주셔서 감사합니다. 🙇‍♂️

> 참고로 게임에 사용된 동물 아이콘 이미지의 경우는 저작권 문제를 고려해서, `DALL-E 2`를 사용하여 기초 이미지를 뽑아내고 포토샵으로 직접 수정하여 제작하거나(사자, 쥐, 강아지, 토끼, 오리, 고양이), 픽셀 아트 사이트에서 직접 도트를 찍어 만든 동물 이미지(너구리, 돼지, 팬더, 아이템 수평, 아이템 수직, 아이템 사방) 입니다 😁

<div style={{ textAlign: "center" }}>
  <iframe
    style={{ width: "80%", height: window.innerHeight - 200 }}
    scrolling='no'
    title='Game-Pang'
    src='https://codepen.io/kkn1125/embed/LYMXeWp?default-tab=&theme-id=dark&zoom=0.5#result-box'
    frameBorder='no'
    loading='lazy'
    allowtransparency='true'
    allowFullScreen={true}>
    See the Pen <a href='https://codepen.io/kkn1125/pen/LYMXeWp'>Game-Pang</a>
    by kkn1125 (<a href='https://codepen.io/kkn1125'>@kkn1125</a>) on
    <a href='https://codepen.io'>CodePen</a>.
  </iframe>
</div>

---

📚 함께 보면 좋은 내용

[DevKimson :: Game Pang](https://kkn1125.github.io/game-pang/)

[MDN Web Docs - Canvas API](https://developer.mozilla.org/docs/Web/API/Canvas_API)

[MDN Web Docs - Optimizing canvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas)
